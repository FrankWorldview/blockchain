# üé® Introduction to ERC-721 Tokens

## 1. What is an ERC-721 Token?

**ERC-721** is the standard for **non-fungible tokens (NFTs)** on the Ethereum blockchain. Introduced in [EIP-721](https://eips.ethereum.org/EIPS/eip-721), it enables the creation of unique digital assets‚Äîeach token has a distinct ID and may have unique metadata.

### Key Properties

- **Non-fungible**: Each token is distinct and not interchangeable.
- **On-chain ownership**: Ownership is tracked via the Ethereum ledger.
- **Metadata support**: Each token can point to off-chain or on-chain metadata (e.g., images, traits, files).

## 2. Use Cases

- Digital art and collectibles
- Game items (weapons, skins, land)
- Real estate or intellectual property representation
- Identity or certificates (e.g., diplomas, access passes)

---

## 3. ERC-721 Interface Functions

The core ERC-721 interface includes:

| Function | Description |
|----------|-------------|
| `balanceOf(address owner)` | Returns the number of NFTs owned by `owner`. |
| `ownerOf(uint256 tokenId)` | Returns the current owner of a given `tokenId`. |
| `safeTransferFrom(address from, address to, uint256 tokenId)` | Safely transfers a token, checking for recipient contract compatibility. |
| `transferFrom(address from, address to, uint256 tokenId)` | Transfers token ownership. Not recommended‚Äîuse `safeTransferFrom` instead. |
| `approve(address to, uint256 tokenId)` | Approves `to` to transfer the given token. |
| `getApproved(uint256 tokenId)` | Returns the approved address for a token. |
| `setApprovalForAll(address operator, bool approved)` | Approves or revokes an operator for all caller‚Äôs tokens. |
| `isApprovedForAll(address owner, address operator)` | Checks if operator is approved for all tokens of `owner`. |

### Events

| Event | Description |
|-------|-------------|
| `Transfer(address indexed from, address indexed to, uint256 indexed tokenId)` | Emitted when ownership of an NFT changes. |
| `Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)` | Emitted when an approval is set for a specific token. |
| `ApprovalForAll(address indexed owner, address indexed operator, bool approved)` | Emitted when an operator is approved or disapproved for all tokens of an owner. |

---

## 4. Example: Using OpenZeppelin‚Äôs ERC721 Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MyNFT is ERC721 {
    uint256 public nextTokenId;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mint() public {
        _mint(msg.sender, nextTokenId);
        nextTokenId++;
    }
}
```

### üõ†Ô∏è Explanation

- `ERC721("MyNFT", "MNFT")`: Sets the token name and symbol.
- `mint()`: Mints a new unique NFT to the caller's address.
- `nextTokenId`: Ensures each token has a unique identifier.

---

## 5. ‚úÖ Best Practices

- Use `safeTransferFrom()` instead of `transferFrom()` to ensure safe token transfers, especially when sending to contracts.
- Implement metadata standards by providing `tokenURI()` to return off-chain JSON metadata via IPFS or HTTPS.
- Use `ERC721URIStorage` when you need to assign and store a unique metadata URI on-chain for each token, without overriding `tokenURI()` manually.

---

## 6. ‚ö†Ô∏è Common Pitfalls

| Pitfall                                                | Consequence                                                                 |
|--------------------------------------------------------|----------------------------------------------------------------------------|
| Not implementing `tokenURI()`                          | NFTs may not render correctly on platforms like OpenSea or in wallets.     |
| Using `transferFrom()` with non-compliant contracts    | May cause NFTs to be permanently locked or lost if the recipient can't handle ERC-721. |
| Minting tokens with duplicate `tokenId`s               | Breaks token uniqueness and may lead to reverts or logic bugs.              |

---

## 7. üñºÔ∏è Metadata Standards and `tokenURI()`

NFTs typically use metadata to describe their visual or functional properties ‚Äî including name, image, and custom traits. In ERC-721, this is accessed through the `tokenURI(uint256 tokenId)` function, which returns a URI that points to a JSON metadata file.

---

### üîó Off-Chain Metadata (IPFS or HTTPS)

The `tokenURI()` function usually returns a URI pointing to a JSON file stored **off-chain**, commonly using:

- **IPFS**: `ipfs://Qm.../123.json`
- **HTTPS**: `https://example.com/metadata/123.json`

Example JSON structure:

```json
{
  "name": "Cool NFT #123",
  "description": "A unique digital collectible.",
  "image": "ipfs://Qm.../image.png",
  "attributes": [
    { "trait_type": "Background", "value": "Purple" },
    { "trait_type": "Power", "value": 9001 }
  ]
}
```

### ‚úÖ Benefits of Off-Chain Metadata

- **Efficient**: Keeps on-chain storage costs low.
- **Flexible**: Metadata can be updated or relocated without modifying the smart contract.
- **Compatible**: Widely supported by NFT marketplaces and platforms like OpenSea, Rarible, and wallets.

---

## 8. üóÉÔ∏è On-Chain URI Storage with `ERC721URIStorage`

OpenZeppelin‚Äôs `ERC721URIStorage` is an extension of the standard ERC-721 contract. It allows developers to store a **unique metadata URI** for each token **directly on-chain**, using built-in storage mappings and helper functions.

---

### üîÅ Relationship Between `ERC721URIStorage`, `_setTokenURI()`, and `tokenURI()`

| Component            | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| `ERC721URIStorage`   | ERC-721 extension that stores URIs in a mapping and provides `tokenURI()`   |
| `_setTokenURI()`     | Internal function used to save a URI for a given `tokenId`                  |
| `tokenURI(tokenId)`  | Public `view` function that retrieves the stored URI for a given `tokenId`  |

> Think of `_setTokenURI()` as the **‚Äúwrite‚Äù** operation, and `tokenURI()` as the **‚Äúread‚Äù** operation.

---

### üì¶ Example

```solidity
contract MyNFT is ERC721URIStorage {
    uint256 public nextTokenId;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mint(string memory uri) public {
        _mint(msg.sender, nextTokenId);              // Create the NFT
        _setTokenURI(nextTokenId, uri);              // Store the URI on-chain
        nextTokenId++;
    }
}
```

### üîç In This Example

- `_mint()` assigns ownership of the token to the caller.
- `_setTokenURI()` stores the metadata URI for that specific token ID in on-chain contract storage.
- `tokenURI()` retrieves the stored URI when queried by wallets, marketplaces, or other contracts.

---

### ‚úÖ Benefits of `ERC721URIStorage`

- **On-chain storage of metadata URIs** ensures permanence, traceability, and immutability.
- **No need to manually override `tokenURI()`**, reducing boilerplate and potential bugs.
- **Ideal for static metadata** such as certificates, credentials, digital art, and NFTs that do not require dynamic metadata generation.

---

### üß† Summary

| Approach              | Description                                           | Stored On-Chain? | Common Use Case                         |
|-----------------------|-------------------------------------------------------|------------------|------------------------------------------|
| `tokenURI()` (custom) | Manually override to generate or return off-chain URI | ‚ùå               | Dynamic metadata (IPFS, HTTPS)           |
| `ERC721URIStorage`    | Store a unique URI on-chain using `_setTokenURI()`    | ‚úÖ               | Static, verifiable metadata per token    |

