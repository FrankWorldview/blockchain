# üé® Introduction to ERC-721 Tokens

## 1. What is an ERC-721 Token?

**ERC-721** is the standard for **non-fungible tokens (NFTs)** on the Ethereum blockchain. Introduced in [EIP-721](https://eips.ethereum.org/EIPS/eip-721), it enables the creation of unique digital assets‚Äîeach token has a distinct ID and may have unique metadata.

### Key Properties

- **Non-fungible**: Each token is distinct and not interchangeable.
- **On-chain ownership**: Ownership is tracked via the Ethereum ledger.
- **Metadata support**: Each token can point to off-chain or on-chain metadata (e.g., images, traits, files).

## 2. Use Cases

- Digital art and collectibles
- Game items (weapons, skins, land)
- Real estate or intellectual property representation
- Identity or certificates (e.g., diplomas, access passes)

---

## 3. ERC-721 Interface Functions

The core ERC-721 interface includes:

| Function | Description |
|----------|-------------|
| `balanceOf(address owner)` | Returns the number of NFTs owned by `owner`. |
| `ownerOf(uint256 tokenId)` | Returns the current owner of a given `tokenId`. |
| `safeTransferFrom(address from, address to, uint256 tokenId)` | Safely transfers a token, checking for recipient contract compatibility. |
| `transferFrom(address from, address to, uint256 tokenId)` | Transfers token ownership. Not recommended‚Äîuse `safeTransferFrom` instead. |
| `approve(address to, uint256 tokenId)` | Approves `to` to transfer the given token. |
| `getApproved(uint256 tokenId)` | Returns the approved address for a token. |
| `setApprovalForAll(address operator, bool approved)` | Approves or revokes an operator for all caller‚Äôs tokens. |
| `isApprovedForAll(address owner, address operator)` | Checks if operator is approved for all tokens of `owner`. |

### Events

| Event | Description |
|-------|-------------|
| `Transfer(address indexed from, address indexed to, uint256 indexed tokenId)` | Emitted when ownership of an NFT changes. |
| `Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)` | Emitted when an approval is set for a specific token. |
| `ApprovalForAll(address indexed owner, address indexed operator, bool approved)` | Emitted when an operator is approved or disapproved for all tokens of an owner. |

---

## 4. Example: Using OpenZeppelin‚Äôs ERC721 Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MyNFT is ERC721 {
    uint256 public nextTokenId;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mint() public {
        _mint(msg.sender, nextTokenId);
        nextTokenId++;
    }
}
```

### üõ†Ô∏è Explanation

- `ERC721("MyNFT", "MNFT")`: Sets the token name and symbol.
- `mint()`: Mints a new unique NFT to the caller's address.
- `nextTokenId`: Ensures each token has a unique identifier.

---

## 5. Best Practices

- Use `safeTransferFrom()` instead of `transferFrom()` for compatibility and safety.
- Use metadata standards (e.g., `tokenURI()`) to point to off-chain data like IPFS or HTTPS.
- Consider `ERC721URIStorage` if you want to store URIs directly on-chain.

---

## 6. Common Pitfalls

| Pitfall | Consequence |
|--------|-------------|
| Not implementing `tokenURI()` | NFT may not display properly in wallets and marketplaces. |
| Using `transferFrom()` on contracts that don't support ERC-721 | May result in locked or lost tokens. |
| Minting NFTs with duplicate IDs | Breaks uniqueness and can cause unexpected behavior. |

## 7. üñºÔ∏è Metadata Standards and `tokenURI()`

NFTs typically use metadata to describe the asset they represent ‚Äî such as name, description, image, and attributes. The standard way to provide this metadata in ERC-721 is through the `tokenURI(uint256 tokenId)` function.

---

### üîó Off-Chain Metadata (IPFS or HTTPS)

The `tokenURI()` function usually returns a URI pointing to a JSON file stored **off-chain**, commonly using:

- **IPFS** (e.g., `ipfs://Qm.../123.json`)
- **HTTPS** (e.g., `https://example.com/metadata/123.json`)

This metadata is structured as a JSON file like:

```json
{
  "name": "Cool NFT #123",
  "description": "A unique digital collectible.",
  "image": "ipfs://Qm.../image.png",
  "attributes": [
    { "trait_type": "Background", "value": "Purple" },
    { "trait_type": "Power", "value": 9001 }
  ]
}
```
### ‚úÖ Benefits of Off-Chain Metadata (IPFS or HTTPS)

- **Efficient**: Keeps on-chain data minimal.
- **Flexible**: Easily update or host metadata anywhere.
- **Common**: Supported by NFT marketplaces like OpenSea.

---

### üóÉÔ∏è On-Chain URI Storage with `ERC721URIStorage`

OpenZeppelin‚Äôs `ERC721URIStorage` extension adds functionality to **store metadata URIs directly on-chain** for each token.

#### Adds:

```solidity
mapping(uint256 => string) private _tokenURIs;

function _setTokenURI(uint256 tokenId, string memory _uri) internal;

### üì¶ Example

```solidity
contract MyNFT is ERC721URIStorage {
    uint256 public nextTokenId;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mint(string memory uri) public {
        _mint(msg.sender, nextTokenId);
        _setTokenURI(nextTokenId, uri); // Store URI on-chain
        nextTokenId++;
    }
}
```
### ‚úÖ Benefits

- **Token metadata URI is stored permanently on-chain.**
- **No need to override `tokenURI()` manually.**
- **Useful for applications that require full on-chain traceability.**

---

### üß† Summary

| Approach              | Description                                | Stored On-Chain? | Common Use Case                          |
|-----------------------|--------------------------------------------|------------------|------------------------------------------|
| `tokenURI()` (custom) | Override to return off-chain metadata URI  | ‚ùå               | Dynamic metadata (IPFS, HTTPS)           |
| `ERC721URIStorage`    | Store per-token URI in contract storage    | ‚úÖ               | Static metadata with URI saved per token |
