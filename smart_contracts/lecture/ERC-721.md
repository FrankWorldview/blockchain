# 🎨 Introduction to ERC-721 Tokens

## 1. What is an ERC-721 Token?

**ERC-721** is the standard for **non-fungible tokens (NFTs)** on the Ethereum blockchain. Introduced in [EIP-721](https://eips.ethereum.org/EIPS/eip-721), it enables the creation of unique digital assets—each token has a distinct ID and may have unique metadata.

### Key Properties

- **Non-fungible**: Each token is distinct and not interchangeable.
- **On-chain ownership**: Ownership is tracked via the Ethereum ledger.
- **Metadata support**: Each token can point to off-chain or on-chain metadata (e.g., images, traits, files).

## 2. Use Cases

- Digital art and collectibles
- Game items (weapons, skins, land)
- Real estate or intellectual property representation
- Identity or certificates (e.g., diplomas, access passes)

---

## 3. ERC-721 Interface Functions

The core ERC-721 interface includes:

| Function | Description |
|----------|-------------|
| `balanceOf(address owner)` | Returns the number of NFTs owned by `owner`. |
| `ownerOf(uint256 tokenId)` | Returns the current owner of a given `tokenId`. |
| `safeTransferFrom(address from, address to, uint256 tokenId)` | Safely transfers a token, checking for recipient contract compatibility. |
| `transferFrom(address from, address to, uint256 tokenId)` | Transfers token ownership. Not recommended—use `safeTransferFrom` instead. |
| `approve(address to, uint256 tokenId)` | Approves `to` to transfer the given token. |
| `getApproved(uint256 tokenId)` | Returns the approved address for a token. |
| `setApprovalForAll(address operator, bool approved)` | Approves or revokes an operator for all caller’s tokens. |
| `isApprovedForAll(address owner, address operator)` | Checks if operator is approved for all tokens of `owner`. |

### Events

| Event | Description |
|-------|-------------|
| `Transfer(address indexed from, address indexed to, uint256 indexed tokenId)` | Emitted when ownership of an NFT changes. |
| `Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)` | Emitted when an approval is set for a specific token. |
| `ApprovalForAll(address indexed owner, address indexed operator, bool approved)` | Emitted when an operator is approved or disapproved for all tokens of an owner. |

---

## 4. Example: Using OpenZeppelin’s ERC721 Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MyNFT is ERC721 {
    uint256 public nextTokenId;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mint() public {
        _mint(msg.sender, nextTokenId);
        nextTokenId++;
    }
}
```

### 🛠️ Explanation

- `ERC721("MyNFT", "MNFT")`: Sets the token name and symbol.
- `mint()`: Mints a new unique NFT to the caller's address.
- `nextTokenId`: Ensures each token has a unique identifier.

---

## 5. ✅ Best Practices

- Use `safeTransferFrom()` instead of `transferFrom()` to ensure safe token transfers, especially when sending to contracts.
- Implement metadata standards by providing `tokenURI()` to return off-chain JSON metadata via IPFS or HTTPS.
- Use `ERC721URIStorage` when you need to assign and store a unique metadata URI on-chain for each token, without overriding `tokenURI()` manually.

---

## 6. ⚠️ Common Pitfalls

| Pitfall                                        | Consequence                                                 |
|------------------------------------------------|-------------------------------------------------------------|
| Not implementing `tokenURI()`                  | NFT may not display correctly in wallets and marketplaces.  |
| Using `transferFrom()` without safety checks   | Can result in tokens being permanently locked or lost if the recipient contract doesn’t support ERC-721. |
| Minting NFTs with duplicate `tokenId`s         | Violates uniqueness, causing overwrites or unexpected behavior. |

---

## 7. 🔄 Dynamic Metadata vs. 📦 Static Metadata (using `ERC721URIStorage`)

ERC-721 tokens can deliver metadata in two main ways: **dynamic** (generated on the fly) or **static** (stored on-chain). The right choice depends on whether your NFTs need to evolve or remain permanent.

---

### 🔄 Dynamic Metadata

- **How it works**: You manually override `tokenURI()` to compute or return the URI.
- **Storage**: Metadata is **not stored** on-chain — only the function returns a URI.
- **Flexibility**: High — you can change logic to generate different metadata at any time.
- **Gas Cost**: Lower — no on-chain storage required.
- **Use Cases**:
  - Evolving game items or characters
  - NFTs with changeable traits
  - Dynamic SVG rendering
- **Considerations**:
  - Requires more development effort.
  - You are responsible for formatting and external hosting.

#### Example:

```solidity
function tokenURI(uint256 tokenId) public view override returns (string memory) {
    return string(abi.encodePacked("https://example.com/meta/", Strings.toString(tokenId), ".json"));
}
```

### 📦 Static Metadata (using `ERC721URIStorage`)

- **How it works**: You call `_setTokenURI(tokenId, uri)` to store the URI in the contract.
- **Storage**: Metadata URI is stored **on-chain** in a mapping.
- **Flexibility**: Low — URI is fixed unless explicitly updated.
- **Gas Cost**: Higher — uses contract storage.
- **Use Cases**:
  - Digital certificates  
  - Profile or identity NFTs  
  - Digital art or collectibles with fixed traits
- **Considerations**:
  - Very simple to use with OpenZeppelin.
  - Fully compatible with all major NFT marketplaces.

#### Example:

```solidity
function mint(string memory uri) public {
    _mint(msg.sender, tokenId);
    _setTokenURI(tokenId, uri);
}
```

### 🧾 Example Metadata (Off-Chain JSON)

Regardless of how `tokenURI()` is implemented—dynamically or using `ERC721URIStorage`—it typically points to a JSON file that describes the NFT’s properties.

Example metadata file:

```json
{
  "name": "Cool NFT #123",
  "description": "A unique digital collectible.",
  "image": "ipfs://Qm.../image.png",
  "attributes": [
    { "trait_type": "Background", "value": "Purple" },
    { "trait_type": "Power", "value": 9001 }
  ]
}
```
> 🧠 This JSON file is used by wallets and NFT marketplaces (like OpenSea or Rarible) to display the NFT’s **image**, **name**, and **attributes** in a user-friendly way.

---

### 🧠 Summary

| Feature               | 🔄 Dynamic Metadata                | 📦 Static Metadata (`ERC721URIStorage`)     |
|------------------------|------------------------------------|---------------------------------------------|
| **Implementation**     | Override `tokenURI()` manually     | Use `_setTokenURI()` during mint            |
| **On-Chain Storage**   | ❌ No                              | ✅ Yes                                       |
| **Flexibility**        | ✅ High                            | ❌ Low (fixed after mint)                    |
| **Gas Cost**           | Low                                | Higher (due to storage writes)              |
| **Marketplace Support**| ✅ Yes (if URI resolves properly)  | ✅ Fully compatible                          |
| **Use Case Fit**       | Games, evolving NFTs               | Art, credentials, permanent assets          |

---

### 🚀 Which Should You Use?

| Your NFT Use Case                                | Recommended Approach                      |
|--------------------------------------------------|--------------------------------------------|
| RPG items, NFTs with upgradeable traits          | 🔄 Dynamic Metadata                        |
| Certificates, identity badges, static assets     | 📦 Static Metadata (`ERC721URIStorage`)    |
| On-chain generative art or animated SVGs         | 🔄 Dynamic Metadata (custom rendering)     |
